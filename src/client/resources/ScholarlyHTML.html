<!DOCTYPE html>
<html lang="ro">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Scholarly HTML</title>
    <link rel="stylesheet" href="https://w3c.github.io/scholarly-html/css/scholarly.min.css">
    <link rel="icon" href="../../sprites/rq-icon.ico" type="image/x-icon" />
    <script src="https://w3c.github.io/scholarly-html/js/scholarly.min.js"></script>
</head>

<body prefix="schema: http://schema.org" style="font-family: calibri !important; font-size: 14pt;">
    <header>
        <h1>Real Quest</h1>
    </header>

    <div role="contentinfo">
        <dl>
            <dt>Autori</dt>
            <dd>
                <a href="https://github.com/blox-dev">Crainiciuc Călin Ștefan</a>
                &amp;
                <a href="https://github.com/firststef">Petrovici Ștefan</a>
                &amp;
                <a href="https://github.com/ancestor-mithril">Stoica George</a>

            </dd>
            <dt>Erori și recomandări</dt>
            <dd>
                <a href="https://github.com/firststef/twproj/issues">Issues and PRs welcome!</a>
            </dd>

            <dt>Licență</dt>
            <dd>
                <a href="">!! nu stiu daca trebuie pus ceva aici???</a>
            </dd>
        </dl>
    </div>
    <section typeof="sa:Abstract" id="abstract" role="doc-abstract">
        <h2>Concept</h2>
        <p>
            <i>Real Quest</i> este o aplicație-joc care permite utilizatorilor să se materializeze într-un tărâm mistic,
            copie a lumii reale, pentru a explora și vâna monștrii care vor să elimine orice formă de viață.
        </p>
    </section>
    <section id="introduction" role="doc-introduction">
        <h2>Introducere</h2>
        <p>
            Jocul <i>Real Quest</i> apelează la servicii web pentru a prelua informații despre locația utilizatorului și
            mediul în care se află, simulând mișcarea acestuia pe o hartă. Elementele spațio-temporale reale sunt
            însoțite de monștrii virtuali, care vor ataca jucătorul.
        </p>
        <p>
            Clientul poate să exploreze împrejurimile, orientându-se dupa detalii precum numele de străzi și de clădiri,
            luptându-se cu monștri pentru a câstiga puncte și a supraviețui cât mai mult.
        </p>
    </section>
    <section id="motivation">
        <h2>Motivație</h2>
        <p>
            Acest sit web reprezintă tema noastră de proiect pentru cursul Tehnologii Web al Facultății de
            Informatică al Universității Alexandru Ioan Cuza. Ideea proiectului a fost adusă de noi, fiind pasionați
            de jocuri, prin care ne-am propus să invățăm cât mai multe despre web în timp ce construim ceva interactiv,
            care să ne placă atât nouă, cât și altora.
        </p>
    </section>
    <section id="problem">
        <h2>Formula proiectului</h2>
        <p>
            Pe baza unui API REST ori GraphQL propriu, să se realizeze o aplicație web de tip joc "Monster hunter"
            utilizând hărți reale preluate de la un serviciu web de cartografiere (ex. Google maps sau
            openstreetmaps.org). În joc vor fi simulate condițiile de vreme exterioare (vreme și luminozitate),
            parametri preluați de asemenea de la servicii web specializate. Locația de start a jucătorului va fi
            preluată prin intermediul API-ului de geolocalizare pus la dispoziție în HTML5 și jucătorul va fi capabil să
            vadă alți jucători pe hartă comunicând în timp real cu serverul utilizând WebSockets.
        </p>
        <p>
            Scopul jocului este de a obține cât mai multe puncte din învingerea inamicilor, monștri ce apar pe harta
            preluată cum s-a menționat mai sus. Inamicii -- folosind o strategie euristică -- se apropie de avatarul 
            jucătorului și dacă acesta nu se ferește de proiectilele lor, viața sa va scădea progresiv ( în concordanță
            cu artileria din dotarea inamicilor) până când va ajunge la zero puncte de vitalitate -- în acest caz,
            jocul se va termina pentru acel jucător și punctajul său este considerat final. În același mod, inamicii
            pot fi învinși prin scăderea punctelor de vitalitate prin contactul cu proiectilele jucătorului. La
            finalul jocului se va afișa un clasament global al jucătorilor și punctajele lor.
        </p>
        <p>
            Sistemul va furniza în timp real clasamentul global al primilor N jucători și punctajele lor (minimal, în
            format XML, CSV). De asemenea se va permite descărcarea într-un format specific traiectoriilor GPS (ex.
            format GPX) a traseului parcurs de jucător în lumea reală.
        </p>
    </section>
    <section id="game">
        <h2>Implementarea jocului</h2>

        <section id="preparation">
            <h3>Pregătire și considerente</h3>
            <p>Primul pas a fost documentarea legată de api-urile pe care le vom utiliza. Am utilizat 3 api-uri: pentru
                timp, vreme și geolocatie. Api-urile aparțin domeniilor <a href ="https://dev.virtualearth.net">dev.virtualearth.net</a>,
                <a href ="https://openweathermap.org">openweathermap.org</a> și <a href ="https://mapbox.com">mapbox.com</a>.
                Serverul preia informațiile necesare clientului, iar aplicația client comunica REST cu serverul prin
                api-ul nostru pentru a inițializa condițiile exterioare și harta. Vom detalia utilizarea
                lor în <a href="#api">capitolele următoare</a>.</p>

            <p>Am început implementarea prin construirea mecanicilor de bază a jocului. Platforma noastră de dezvoltare
                fiind Web-ul, mai specific, formatul HTML5, am ales ca tehnologie prinicpală HTML5 Canvas. Pentru acest
                joc, aveam nevoie de:
                <div style="padding-left:3em;">
                - o modalitate prin care să desenăm forme geometrice în zone diferite (ex. clădirile) <br>
                - folosirea de imagini (sprite-uri pentru personaj, monștri) <br>
                - capturarea comenzilor utilizatorului <br>
                - animații de sprite-uri (pentru mișcarea jucătorului) <br>
                - să putem muta formele geometrice <br>
                </div>
            </p>
            <p>
                Primele 3 cerințe erau îndeplinite nativ de canvas, însă pentru următoarele două lucrurile nu erau așa
                de simplu de realizat.
            </p>
            <p>
                În primul rând animațiile trebuiau realizate prin împărțirea foii de animație (spritesheet) în mai multe
                cadre, și înlocuirea cadrului curent la un anumit interval, în funcție de viteza animației.
            </p>
            <p>
                În al doilea rând, mutarea entităților desenate pe ecran necesită o arhitectură arborescentă, în care
                fiecare nod copil se orienta relativ la părintele său. Un exemplu de ce este nevoie de aceasta: știm că
                pentru a observa efectul de mișcare a personajului trebuie să observăm o translație a obiectelor din
                interiorul lumii pe măsură ce jucătorul se mișcă, și de asemenea trebuie că acesta să rămână în mijlocul
                ecranului, pentru ca utilizatorul să vadă la fel de mult din hartă pe măsură ce o parcurge. Pentru a
                crea acest efect în interiorul lumii 2d create, observăm că vom avea nevoie de un nod părinte, care
                conține obiectele lumii, inclusiv personajul, și trebuie să mutăm personajul relativ la acest nod, în
                funcție de input. Ceea ce nu este așa de evident este că tot în același timp trebuie să mutăm și lumea
                cu totul, pentru a urmări personajul și a-l menține în mijloc (nu avem în canvas conceptul de cameră
                virtuală, care poate să inspecteze obiecte într-o locație oarecare, ci noi desenăm pe un viewport, și
                deci trebuie să mutăm obiectele). Fără o arhitectură și o implementare care să ne ofere suportul pentru
                relațiile de tip părinte-copil, lucrul acesta ar fi fost extrem de dificil.
            </p>
            <p>                
                În urma realizărilor acestor două cerințe, ne-am dat seama că o implementare elaborată a
                acestora ar dura foarte mult. Din acest motiv, am căutat o implementare open-source ca să ne ajute. Așa
                am descoperit <a href="https://createjs.com/">CreateJS</a>, o librărie cu o licență deschisă și care are
                implementări esențiale pentru jocul nostru.
            </p>
        </section>
        <section id="createjs">
            <h3>Cum am folosit <a href="https://createjs.com/">CreateJS</a></h3>
            <p>
                Librăria permite să instanțiem forme geometrice și imagini animate (sprite-uri) prin construirea de
                obiecte. Principiul de bază este următorul: nodul rădăcină este instanțiat ca un obiect de tip Stage,
                și pentru fiecare copil adăugat lui, nodul părinte îl va orienta în funcție de poziția proprie și
                deplasament.
            </p>
            <p>
                Cum pentru proiect exista restricția de a nu folosi decat librarii, am avut grijă ca alegerea noastră să
                nu fie framework, si am judecat că aceasta îndeplinește condiția luând în considerare următoarele:
                <div style="padding-left:3em;">
                - funcțiile din createjs reprezintă "ambalaje" peste funcțiile clasice de desenat pe canvas, pastrând
                declarații similare cu cele din api-ul original.<br>
                - clasele din createjs pot fi instanțiate de noi când dorim, având control complet asupra obiectelor din
                lume <br>
                - createJs nu rulează independent de codul nostru, poziția obiectelor pe canvas se actualizează doar
                când apelăm stage.update(), stage fiind tot un obiect instanțiat de noi.
                </div>
            </p>
            <p>
                CreatJs are un obiect folosit pentru optimizare pe browser, Ticker, care are un rol de timer - calculează
                în funcție de frecvența cadrelor pe care o dorim, când trebuie să apelăm
                bucla principală (funcția de actualizare) a jocului, care este definită de noi.
            </p>
            <p>
                După ce am capturat tastele apăsate de utilizator și am introdus o imagine pentru caracter, am reușit să
                creăm un personaj care se putea orienta in spațiu.
            </p>
        </section>
        <section id="map">
            <h3>Realizarea hărții</h3>
            <p>  
                API-ul de geolocație preia coordonate pentru străzi, clădiri, și mase de apă și le creează ca obiecte pe hartă.
                Ordinea în care desenăm obiectele creează și efectul de stratificare, necesar pentru noi pentru ca jucătorul să
                se poziționeze deasupra străzilor și nu sub acestea. Modul în care preluăm coordonatele este descris în secțiunea
                de mai jos, despre <a href="#mapbox">Mapbox</a>. Coordonatele pe care le primim sunt puse în vectori sau multivectori de
                coordonate. Un vector de coordonate reprezintă conturul unei străzi,clădiri sau mase de apă. Coordonatele
                clădirilor sunt păstrate în două locuri: prima dată ca și formă geometrică pe ecran, iar a două oară
                într-un vector ca să ne dăm seama când o clădire a fost deja primită și desenată, și să calculăm
                coliziunile cu jucătorii.
            </p>
            <p>
                După ce am adăugat clădirile, am adăugat și un algoritm pentru coliziune, la început foloseam o librărie cu
                un algoritm bazat pe intersecție de poligoane, dar după, am renunțat la ea întrucât caluclele erau realizate
                prea lent și am făcut o implementare mai optimă, calculând distanțe față de muchiile clădirii. Am adăugat
                două optimizări pentru coliziune, prima calculează limite pentru clădire și se asigură că vom face operația
                de calcul de coliziune (care este costisitoare) doar în interiorul acestei limite, iar a doua calcula intr-un
                interval limitele clădirilor și elimina clădirile îndepărtate, aplicând coliziunea doar pe cele care erau în raza
                de acțiune a jucătorului.
            </p>
        </section>
        <section id="weather">
            <h3>Afișarea vremii</h3>
            <p>
                Apelând serviciile pentru timp și vreme, având ca parametru locația curentă a jucătorului,
                distingem tipul vremii: însorit, înnourat cu ploaie, ninsoare și tipul de luminozitate: luminos sau
                întunecat. În cazul în care serviciul eșuează, am implementat o funcție care calculează aproximativ ora pe glob
                după deplasarea față de Greenwich și o întoarce.
            </p>
            <p>
                Pentru animația de ninsoare și ploaie, a fost necesar să folosim api-ul nativ pentru setări
                mai avansate: ploaia trebuia să aibă o animație, și de asemenea, pentru a optimiza sprite-ul (să nu avem
                o imagine mare formată din imagini mici repetate), buffer-ul sprite-ului trebuia repetat pe tot ecranul.
                În plus, am explicat mai sus că pentru a crea efectul de mișcare, trebuie să mutăm personajul, dar și
                lumea, ca să păstrăm în mijlocul ecranului caracterul. Doar că lumea trebuie mutată în sens invers mișcării
                personajului. Deci, trebuia să deplasăm originea imaginii cu aceeași distanță de deplasare a jucătorului.
                Clasele din CreateJS pot folosi funcții trimise de noi în care apelăm funcțiile de canvas native, acesta
                fiind modul de lucru pentru efectele complexe. Am realizat o astfel de funcție, CreateJS-ul se asigură
                de schimbarea animației iar noi desenăm pe tot ecranul animația curentă și cu deplasamentul potrivit
                mișcării.
            </p>
        </section>
        <section id="loading">
            <h3>Incărcarea resurselor</h3>
            <p>
                Pe lângă api-urile care sunt accesate la început, încarcă imaginile pentru jucător,
                monștri etc. Cum această încărcare se realizează asincron, nu știm exact care dintre apelurile asincrone
                se va termina primul sau în ce ordine. Trebuie să așteptăm câteva secunde pentru ca acestea să se
                termine, și se vedea o pagină goală până începea jocul, așa că am creat o pagină temporară de încărcare
                și am creat PageLoader, o clasa care înregistrează funcții asincrone și le apeleaza după ce
                toate funcțiile sunt pregătite. Am adăugat și pictograme care să arate progresul, dacă s-a încărcat sau
                nu resursa respectivă.
            </p>
            <p>
                Imaginile se încarcă cu ajutorul unei clase din createjs, LoadQueue. Buffer-ul primit este folosit
                apoi la crearea din animații prin împărțirea ei în secțiuni, în funcție de dimensiunea cadrelor și
                numărul lor.
            </p>
            <p>
                Când PageLoader termină așteparea, jocul începe.
            </p>
        </section>
        <section id="mechanics">
            <h3>Mecanicile de bază ale jocului. Interacțiunea cu inamicii.</h3>
            <p>
                Scopul jocului este obținerea unui punctaj cât mai mare. Acesta depinde de câți monștri ai învins și cât
                de mult ai rezistat în joc. Jucătorul se deplasează cu ajutorul tastelor WASD și poate arunca proiectile
                prin alegerea direcției folosind mouse-ul. Jocul se termină când viața caracterului ajunge la 0, adică
                toată bara roșie din stânga-sus a ecranului se golește.
            </p>
            <p>
                În cazul detectării de coliziune cu o clădire, jucătorului nu i se va permite deplasarea spre aceasta.
                Monștrii sunt de două tipuri, primul tip poate lansa proiectile spre personaj, iar al doilea tip este
                mult mai rapid, însă nu are proiectile. Monștrii blochează trecerea, iar dacă sunt în contact cu
                jucătorul, acesta pierde puncte de vitalitate.
            </p>
        </section>
        <section id="bonuses">
            <h3>Bonusuri</h3>
            <p>
                Pe hartă apar din când în când anumite iconițe care reprezintă un avantaj (uneori temporar) pentru
                jucător: sacul de bani reprezintă 50 de puncte în plus, papucul cu aripi oferă câteva secunde de viteză
                dublă, iar cheile mov pot "deschide" clădirile, adică jucătorul poate să treacă prin ele. Cheile sunt
                stivuibile, dar papucii resetează intervalul de viteză la contact.
            </p>
        </section>
        <section id="art">
            <h3>Artă si design</h3>
            <p>
                Un joc este un proiect foarte laborios, pentru că este format din multe elemente: ideea jocului,
                cât de distractivă este aceasta, design-ul jocului, dacă resursele dau un aspect estetic împreună
                (consistență), mecanica de baza a jocului, cât de echilibrate sunt câștigurile față de efortul depus de
                jucător, cât de accesibile sunt controalele etc. Am încercat să avem în vedere toate aceste aspecte,
                realizând cât mai mult din fiecare.
            </p>
            <p>
                Resursele grafice au fost desenate de noi (imaginea personajului și a monștrilor, animațiile, cele
                două imagini cu eroul de pe pagină principală, imaginile pentru bonusuri), dar pot fi folosite de
                cine dorește.
            </p>
            <p>
                De asemenea am scris si o introducere pe pagina principala, pentru a oferi un context jocului. 
            </p>
            <p>
                Pentru majoritatea jocurilor, interfața jocului (UI-ul), este integrată în aceeași tehnologie ca și restul
                jocului. Însă, în loc să o facem din dreptunghiuri, chenare, text, butoane desenate în interiorul
                canvas-ului, am decis să folosim html-ul și css-ul. Până la urmă, aceasta este cea mai utilizată
                tehnologie pentru realizarea de interfețe și este foarte bine testată. În plus, puteam să ne folosim
                direct de cunoștințele legate de front-end, în loc să calculăm și să implementăm noi un sistem pentru
                interfață.
            </p>
        </section>
        <section id="gameEnd">
            <h3>Sfârșitul jocului</h3>
            <p>
                Când jucătorul își pierde toate punctele de vitalitate, jocul afișează punctajul acestuia, locul său
                în clasament și primii jucători. De aici ei pot descărca traseul parcurs si clasamentul primilor 10 jucători,
                in funcție de scor.
            </p>
        </section>
        <section id="formats">
            <h3>Formatele exportate</h3>
            <p>
                Pe parcursul jocului sunt salvate punctele geografice prin care trece jucătorul, iar la final el poate
                descărca un fișier GPX cu traseul parcurs. De asemenea, pe pagina de final, utilizatorul poate descărca
                clasamentul primilor 10 jucători în format CSV.
            </p>
        </section>
        <section id="mobile">
            <h3>Versiunea de mobil</h3>
            <p>
                Pentru versiunea de mobil am adăugat o implementare open-source numită
                <a href="https://github.com/bobboteck/JoyStick/blob/master/joy.js">JOY.JS</a> pentru un joystick
                html5. Pe ecranele mici, sunt 2 joystick-uri: cel din dreapta este pentru mișcarea personajului, iar
                cel din stânga, dacă nu este în starea de bază, trimite un proiectil în direcția în care este îndreptat.
            </p>
        </section>
        <section id="mapbox">
            <h3>Hărțile din Mapbox GL JS</h3>
            <p>              
                Unul din api-urile pe care le-am folosit a fost cel de geolocație. Acesta ne întoarce cele mai apropiate
                obiecte (străzi, clădiri, monumente, etc). Însă problema era că nu ne întorcea coordonatele conturului
                acestora. Am căutat suplimentar față de acesta alt serviciu și am realizat la scurt timp după ce pornisem
                proiectul că nu există un api pentru delimitările clădirilor/ monumentelor/ formelor de relief, care
                să fie accesibil prin cerere http. Până și google, care are o colecție foarte mare de hărți și alte
                api-uri legate de acestea, nu avea un astfel de serviciu.
            </p>
            <p>
                Nici Openstreetmaps, nici alte domenii. Și pe noi ne-a intrigat acest aspect, dar am descoperit un
                serviciu de la Mapbox care permitea descărcarea de fișiere comprimate care conțineau astfel de
                informații.
            </p>
            <p>
                Însă în ciuda efortului depus, nu am reușit să despachetam formatul respective (.pbf/.mvt), la început
                folosind gunzip, sau alte librării, în javascript, în python. Formatul pe care Mapbox îl punea la
                dispoziție pare că se despacheta diferit față de .pbf-urile normale, aparțînând google. Un alt domeniu,
                openstreetmaps, menționa că are datele respective, dar printre implementările oferite de ei pentru
                lucrul cu aceste fișiere, nu am găsit nicio implementare viabilă. Când spunem că nu erau viabile, 
                ne referim la mai multe probleme, în primul rând, noi doream inițial ceva care să fie sub formă de api,
                sau dacă trebuia să despachetam noi formatele, să avem și o librărie care să facă asta,
                dar unele implementări erau sdk-uri, librării cu licență non-open-source, sau scrise în c++ (și nu voiam server în c++).
            </p>
            <p>
                Dar am găsit o soluție până la urmă. Am descoperit că într-o implementare pentru hărți embedded folosind canvas pentru web, era
                posibil pentru noi să interogăm harta la momentul curent și să întoarcem coordonatele clădirilor. Dar,
                din păcate, când am încercat să luăm această librărie să o punem pe server că să încapsulam într-un api
                propriu funcționalitatea, am descoperit că librăria era incompatibilă cu node.js - era doar pentru web.
                Și da, am încercat, în primul rând să reparăm dependințele, după să emulăm un browser pe serverul de
                node, însă, după multe încercări, am renunțat. 
            </p>
            <p>
                În final, pentru a construi harta noastră, ne folosim de harta celor de la Mapbox. Librăria este open-source,
                însă nu am reușit să reproducem cum despachetează exact formatul, am investigat și am trecut din nou prin
                implementări și prin gunzip și prin librării, dar
                a trebuit să alegem că soluție finală utilizarea acestei librării pe front-end. Dacă am fi reușit, am fi
                putut să mutăm clădirile, interacțiunea cu ele pe server, și să facem jocul și mai performant, și chiar
                ne-am fi dorit acest lucru. Însă aveam doar opțiunea de frontend, iar ideea de a transmite coordonatele
                serverului pentru a controla el coliziunea nu ar fi fost un lucru benefic.
            </p>
        </section>
        <section id="multiplayer">
            <h3>Multiplayer</h3>
            <p>
                Un lucru interesant la un joc retro este să ai capabilități multiplayer. În aplicația noastră jucătorii
                își pot observa unul celuilalt poziția, orientarea curentă și pot interacționa prin intermediul
                chat-ului. Totuși, ei nu se vor putea ciocni sau lupta cu monștri împreună. Calculele nu se realizează la
                nivel de server, ci jocul este orientat spre client, din cauză că nu am reușit să mutăm calculele pe server.
            </p>
            <p>
                La începutul jocului se realizează o conexiune cu serverul prin SocketIO (<a href="#socketio">
                detalii mai jos)</a>. Clientul
                trimite la un interval de timp coordonatele serverului, la început mai mare (1s). Dacă jucătorul are în
                jurul său pe altcineva, acest interval se micșorează la o anumită valoare, astfel încât coordonatele să
                fie transmise mai repede pentru a fi actualizate între clienți. Acest mod de comunicare reprezintă o
                optimizare pentru a nu folosi intens resursele atunci când jucătorii nu au pe cineva în proximitatea
                lor.
            </p>
            <p>
                Odată cu coordonatele trimise, jucătorii trimit și punctajul curent, iar serverul realizează un
                clasament al jucătorilor pe care îl oferă prin api. Pe ecranul jocului în colțul din dreapta-sus este
                o tabelă care se actualizează în direct apelând acest api.
            </p>
            <p>
                La deconectare, serverul înțelege că sesiunea de joc a utilizatorului s-a terminat și înregistrează în
                baza de date ultimul punctaj obținut. Clientul va obține prin apelarea api-ului locul său în clasament
                după inserare și vârful clasamentului jucătorilor.
            </p>
        </section>
    </section>
    <section id="app">
        <h2>Implementarea aplicației</h2>

        <section id="site">
            <h3>Realizarea paginilor sitului web</h3>
            <p>
                Pe prima pagină se găsește formularul de intrare în joc. La încărcarea paginii, browser-ul va cere permisiunea
                pentru geolocație. În cazul în care utilizatorul își dă acordul pentru preluarea datelor, se completează
                în formularul de început de joc coordonatele sale. Altfel, el rămâne cu anumite coordonate prestabilite,
                acestea fiind o anumită zonă din Iași, orașul în care a fost implementat acest proiect. După ce un
                utilizator își scrie un username dorit,
                este direcționat pe pagina jocului. Transmiterea coordonatelor și a numelui de utilizator între pagini
                este realizată folosind LocalStorage pe navigatoarele care suportă aceasta, altfel prin intermediul parametrilor
                în adresa url.
            </p>
            <p>
                Paginile au fost analizate să fie valide în conformitate cu standardele. Au fost folosite tool-uri pentru validare
                de html și de css.
            </p>
        </section>
        <section id="server">
            <h3>Pornirea server-ului</h3>
            <p>
                Întrucât începusem să învățăm javascript cu implementarea jocului și din operațiile de frontend, ne-am
                hotărât să păstrăm limbajul și să apelăm la tehnologiile NodeJS. De asemenea aveam la început intenția
                să integrăm algoritmii pentru coliziune și alte funcționalități ale jocului pe server, pentru
                performanță, însă s-a dovedit că trebuie să le păstrăm pe client.
            </p>
            <p>
                Serverul trebuie atât să întoarcă fișierele pentru pagini, cât și să comunice cu clientul prin
                api de tip REST. La început, făceam un switch pentru a detecta dacă resursa cerută este un document sau un api și apelam
                funcțiile potrivite. Un fișier de configurare pe server în format json ne spunea ce fișiere aveam, ruta
                pe care puteau fi accesate și tipul lor. Însă după am renunțat la acest fișier de configurare pentru
                pagini și am recurs la o implementare mai organizată, cea de tip MVC.
            </p>
        </section>
        <section id="mvc">
            <h3>Arhitectura MVC</h3>
            <p>
                Pentru a realiza o arhitectură MVC am creat clasele Router, Controller și Model. Router-ul face legătura
                dintre ruta la care primim request-ul și controller-ul care trebuie să întoarcă răspunsul. Sunt două
                tipuri de controllere: ApiController și ResourceController. ResourceController se ocupă cu citirea
                fișierelor resursă și trimiterea lor, iar ApiController execută o anumită procedură și întoarce
                rezultatul acesteia. Controller-ele comunică cu clasa Model, responsabilă cu accesul la baza de date și
                logica aplicației. Pentru fișierele pe care trebuiau aplicate template-uri, am fi putut utiliza o clasă
                View care să substituie câmpurile ce aveau conținutul '{{ variabilă }}' cu valoarea respectivă din
                Model, însă noi am folosit mai mult api-uri ca să ne umplem conținutul, având nevoie de versiunea live,
                și nu versiunea la încărcare.
            </p>
            <p>              
                Model folosește o clasă asemănătoare cu PageLoader, ApiLoader, și el cu rol de a încărca asincron
                api-urile și a întoarce în același timp răspunsul. Diferența este că în timp ce PageLoader stoca datele
                primite la nivel global, ApiLoader nu poate pune în variabile globale rezultatele și le oferă
                callback-urilor un context local în care să-și pună rezultatul interogarilor și de asemenea rezolva
                request-ul primit doar dacă toate callback-urile au reușit, iar în caz contrar trimite un cod de eroare.
            </p>
        </section>
        <section id="socketio">
            <h3>Comunicarea prin SocketIO</h3>
            <p>
                Websocket-urile permit comunicarea în timp real cu clienții, lucru necesar în momentul în care vrem
                ca jucătorii să se poată vedea unii pe ceilalți în același timp. Pe această tehnologie se bazează
                librăria SocketIO, pe care am integrat-o cu jocul nostru, atât pe partea de server cât și pe partea de
                client. În momentul conectării se creează socket-uri, clientul și serverul rămânând conectați pe tot
                parcursul jocului. Comunicarea începe cu clientul trimițând o cerere HTTP către server cu
                conținutul "Upgrade: websocket". Dacă serverul acceptă, comunicarea se realizează din acel moment cu
                protocolul WS, care trimite și acceptă pachete mai mici, pentru a crește viteza.
            </p>
            <p>
                Serverul și clientul își pot trimite unul altuia evenimente și un buffer de date odată cu acel
                eveniment.
            </p>
            <p>              
                Cea mai des implementată aplicație a websocket-urilor sunt chat-urile, și am vrut să includem și noi o
                fereastră de comunicare. Așa putem folosi funcționalitatea de broadcast a serverului de websocket-uri, care
                atunci când primește un eveniment de la client că s-a trimis un mesaj, face broadcast pentru toți
                clienții conectați cu datele primite.
            </p>
        </section>
        <section id="bd">
            <h3>Baza de date</h3>
            <p>
                Pentru baza de date am folosit MongoDB, fiind o alegere recomandată pentru serverele de NodeJS, și dorind
                să experimentăm cu o baza de date NoSQL. De asemenea serviciile MongoDB ne permiteau să folosim o bază
                de date în cloud gratis, și asta ne-a permis să nu mai îngreunăm proiectul cu o configurație locală a
                bazei de date, noi lucrând fiecare separat.
            </p>
        </section>
        <section id="api">
            <h3>Api-urile create</h3>
            <p>
                Aplicația folosește activ informațiile găsite pe server și le preia comunicând REST cu acesta.
            </p>
            <section id="livescores">
                <h4>Livescores</h4>
                <h5>Ruta: /api/livescores</h5>
                <p>
                    Acest api primește că parametru în url o constantă "count", și întoarce primele "count" înregistrări
                    de utilizatori din lista de jucători activi, sortați după punctaj. Înregistrările sunt în format
                    json cu un vector de obiecte.
                </p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
[{"username": "player1", "currentPoints":"100"}, {"username":"player2", "currentPoints": "11"}...]
                    </pre>
                </figure>
            </section>
            <section id="leaderboards">
                <h4>LeaderBoards</h4>
                <h5>Ruta: /api/leaderboards</h5>
                <p>
                    Acest api returnează primii "count" jucători după punctaj care au terminat jocul, și care au un
                    punctaj mai mare decât parametrul opțional "myScore". Pe lângă vectorul de obiecte, dacă am vrea să
                    știm câți jucători au un punctaj mai mare decât myScore, dar totuși să întoarcem doar "count"
                    elemente, api-ul întoarce numărul de astfel de jucători sub câmpul "myPlace".
                </p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
{"players":[{"username": "player1", "currentPoints":"100"}, {"username":"player2", "currentPoints": "11"}...], "myPlace":"1"}
                    </pre>
                </figure>
            </section>
            <section id="weathertime">
                <h4>Time And Weather</h4>
                <h5>Ruta: /api/environment</h5>
                <p>
                    Api-ul oferă informații despre vreme și timp la coordonatele trimise ca parametri: ["lat", "lng"].
                    În obiectul "weather" sunt mai multe informații, dar jocul folosește în special câmpul "main",
                    care poate fi ["Rain", "Snow", etc.] și câmpul "time" care precizează ora în minute.
                </p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
{"weather": {...},"time": 900}
                    </pre>
                </figure>
            </section>
            <section id="nearby">
                <h4>Nearby Features</h4>
                <h5>Ruta: /api/nearbymessage</h5>
                <p>
                    Acest api întoarce o descriere a locației curente a utilizatorului (trimise ca ["lat", "lng"]),
                    clientul putând afla numele celei mai apropiate străzi, clădiri sau monument. Mesajele
                    sunt personalizate cu formulări misterioase cu rolul de a păstra o nuanță de poveste într-un context
                    realistic.
                </p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
{"name": "Strada Palas","topText": "","bottomText": " is in your sight"}
                    </pre>
                </figure>
            </section>
            <section id="aconfig">
                <h4>Config</h4>
                <h5>Ruta: /api/configuration</h5>
                <p>
                    Nu în ultimul rând este api-ul de config, care întoarce clientului parametri pentru joc, așa cum au
                    fost stabiliți de administator.
                </p>
                <figure typeof="schema:SoftwareSourceCode">
                    <pre>
{"maxNrOfMonsters":10,"isNight":false,"rain":false,"snow":false,"playerMaxHealth":100,"moneyPowerUpValue":50,"displacement":0.000002,"speedDisplacement":1.45,"scale":2.5,"leaderBoardCount":7}
                    </pre>
                </figure>
            </section>
        </section>
        <section id="config">
            <h3>Modulul de configurare</h3>
            <p>
                Ca și administratori ai serverului, putem ajusta anumiți parametri ai jocului în funcție de feedback-ul
                pe care îl primim de la jucători sau dacă observăm un mod prin care putem îmbunătăți experiența jucătorului.
                Aceasta o facem printr-un fișier de configurare, care conține constante pentru joc: câți monștri sunt
                creați la început, numărul de puncte de viață ale jucătorului, vremea globală pentru joc,
                la ce scară este desenată harta etc.
            </p>
        </section>
    </section>
    <section id="development">
        <h2>Procesul de dezvoltare</h2>

        <section id="repo">
            <h3>Github</h3>
            <p>
                Pentru managementul codului sursă am folosit Github. Această platforma a venit cu o mulțime de avantaje,
                și am fost foarte mulțumiți de ea. Pe lângă posibilitatea de a vedea în browser codul sursă și a
                modificărilor făcute pe parcursul proiectului, Github ne-a permis să facem și un "Project Board". Pe aceasta
                pagină noi putem stabili și crea task-uri, ca să știm care este partea din proiect de care trebuie să se
                ocupe fiecare. De asemenea ne arată și statistici, cât de mult am scris, cât de des, și cât mai avem
                până terminăm toate cerințele.
            </p>
        </section>
        <section id="static">
            <h3>Analiza statică</h3>
            <p>
                DeepScan este un analizator static pentru javascript, și ne-a permis să observăm erori sau să ne
                îmbunătățim codul. De exemplu, acesta ne spunea când o variabilă este declarată dar nu este folosită
                nicăieri, când o anumită condiție ajungea să fie îndeplinită mereu, etc. DeepScan oferă analiză gratis
                la conectarea cu Github prin programul Github Student Developer Pack.
            </p>
        </section>
        <section id="deployment">
            <h3>Lansare continuă (Continuous Deployment)</h3>
            <p>
                Probabil cea mai folositoare metodă de testare pentru proiect a fost că am putut avea versiunea live a
                proiectului încă de la început. Folosind oferta gratis de la DigitalOcean în parteneriat cu Github, am
                putut configura o mașină virtuală pe care să pornim serverul nostru. La scurt timp, am adăugat o opțiune în Github
                că la fiecare actualizare a codului să actualizăm și serverul. Am făcut asta utilizând o acțiune
                open-source de la Github prin care putem să inserăm o cheie ssh care să se conecteze la mașină virtuală
                și să facă un git pull, după care să repornească serverul. Inițial eram reticenți la folosirea unei chei
                ssh pe un depozit(repository) public, gândindu-ne că oricine ar putea să ia cheia și să se conecteze la
                server, însă
                Github a implementat foarte inteligent soluția pentru astfel de probleme: pe Github există o secțiune
                numită "Secrets". Aici se pot pune date de tip nume-valoare, date care pot fi folosite în acțiuni, iar
                modul în care acestea oferă securitate sistemului este că odată inserată o valoare, ea nu poate fi
                accesată de niciun membru, ci e posibil să fie utilizată doar în acțiuni. A fost prima dată când am
                implementat o astfel de acțiune, dar cei de la Github au făcut că tot procesul să fie foarte ușor și la
                îndemână de realizat, iar în final, am reușit. Serverul se actualiza la fiecare schimbare care o puneam
                pe depozit.
            </p>
        </section>
        <section id="logging">
            <h3>Înregistrarea erorilor în fișier</h3>
            <p>
                Atunci când serverul nostru este la distanță, se poate întâmpla ca ceva să meargă rău, iar noi să nu
                realizăm sau să putem vedea output-ul pentru că nu avem acces imediat la acea mașină. Pentru asta am
                implementat la fiecare pornire,
                serverul să facă un fișier de loguri într-un folder, și să îl numească utilizând data și ora la care a
                fost
                pornit. Astfel, dacă vom avea nevoie să vedem din ce motiv a picat serverul sau dacă s-a întâmplat ceva
                neprevăzut, putem inspecta fișierele cu erori.
            </p>
            <p>
                Mai trebuie menționat că fișierul de erori a trebuit să-l trecem ca excepție în .gitignore, pentru ca
                să nu existe conflicte de vreun fel când serverul execută operația de pull (ar fi putut vedea un conflict
                între două fișiere de erori numite la fel).
            </p>
        </section>
        <section id="contributions">
            <h3>Contributii</h3>
            <p>Toata echipa a lucrat la joc si fiecare a progresat mult prin acest proiect.</p>
            <p>Ștefan s-a ocupat in principal cu integrarea librăriilor, input-uri pe pagina jocului, proiectilele pentru user, design, resursele grafice, o parte din mvc, unele api-uri pe server, documentație, etc.</p>
            <p>Călin s-a ocupat de pagina principală, monștri, gpx, csv, diagrama c4, o parte din mvc, documentație, etc.</p>
            <p>George a realizat algoritmul de coliziune, proiectilele monștrilor, unele api-uri pe server, câteva bonusuri, documentație, etc.</p>
        </section>
    </section>
    <section id="conclusion">
        <h2>Concluzii</h2>
        <p>
            Dezvoltarea acestui joc ne-a invățat multe aspecte legate de web și ne-a permis să lucrăm la ceva de care suntem pasionați,
            lucru care ne-a motivat pe parcurs. Am realizat că aplicațiile web sunt tehnologii complexe, care necesită multă atenție
            în implementare.
        </p>
    </section>

    <section id="biblio-references">
        <h2>References</h2>
        <ol>
            <li property="schema:citation" role="doc-biblioentry" typeof="schema:ScholarlyArticle"  id="Scholarly-html"
            resource="https://w3c.github.io/scholarly-html/">
                <cite property="schema:name">
                    <a href="https://w3c.github.io/scholarly-html/">Scholarly HTML</a>
                </cite>,
                <span property="schema:author" typeof="schema:Person">
                    <span property="schema:name">Tzviya Siegman (Wiley)</span>&amp;
                    <span property="schema:name">Robin Berjon</span>
                </span>
            </li>
            <li property="schema:citation" role="doc-biblioentry" typeof="schema:WebPage"  id="mapbox-api"
                resource="https://docs.mapbox.com/api/">
                <cite property="schema:name">
                    <a href="https://docs.mapbox.com/api/">Documentație mapbox</a>
                </cite>
            </li>
            <li property="schema:citation" role="doc-biblioentry" typeof="schema:WebPage"  id="create-js"
                resource="https://createjs.com/">
                <cite property="schema:name">
                    <a href="https://createjs.com/">CreateJS</a>
                </cite>
            </li>
            <li property="schema:citation" role="doc-biblioentry" typeof="schema:WebPage"  id="socket-io"
                resource="https://socket.io/">
                <cite property="schema:name">
                    <a href="https://socket.io/">SocketIO</a>
                </cite>
            </li>
            <li property="schema:citation" role="doc-biblioentry" typeof="schema:WebPage"  id="joy-js"
                resource="https://github.com/bobboteck/JoyStick/blob/master/joy.js">
                <cite property="schema:name">
                    <a href="https://github.com/bobboteck/JoyStick/blob/master/joy.js">JOY-JS</a>
                </cite>
            </li>
        </ol>
    </section>

    </section>


</body>

</html>